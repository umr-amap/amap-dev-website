---
title: "Starting a new project"
---

Whether you are writing a full new package or just collect a bunch of scripts, it is important to start your project with a good organization. This will help you to keep your code clean and readable, and will also help you to share your code with others.

Below, you will find some recommendations and things to know before starting your project with a focus on R and Python projects (contributions to other languages are more than welcome !).

# R users
We recommand using Rstudio when starting a R project. It is the most widely used integrated development environment (IDE) by R users and developers.

## Work within a Rstudio project

- File > New Project > New Directory > New Project : renders a `.Rproj` file which will be located at the project root

```
    │
    ├── [my_project]
    │   └── my_project.Rproj
    │
    ├── [another_project]
    │   └── another_project.Rproj
    │
    ├── [again_another_project]
    │   └── again_another_project.Rproj
    │
```

- name your project without blank space and accent

- within your project, always use relative paths from the project root to ensure portability across users (check [here](https://here.r-lib.org/) `R` package.)

## Start version control with git

[How to use git](git.qmd)

## The files you need from the very beginning

- `DESCRIPTION` & `NAMESPACE` files : those are the files that contain metadata of your project (or package). You can generate them with the following command in the R console:

```r
usethis::create_package("mypackage")
```

To edit the DESCRIPTION file, check at the [documentation section](documentation.qmd#description-file). The NAMESPACE file is automatically generated by the `devtools::document()` function.

- LICENSE : you need a license for your project, namely a text file named LICENSE which states under which license your code falls. To choose one refer to <https://choosealicense.com>. For example, GPL-2 <https://choosealicense.com/licenses/gpl-2.0/> is the most widely used free software license.

- README : the README is a text file allowing your reader : (i) to understand the objectives of your project, (ii) how to use it, and (iii) how to install it. You will update the README along the project development.

## How to organize your project repositories

- The idea is to sort the files you are going to produce in different sub-repositories from the project root. Each of the sub-repository will receive a certain type of file. Thus, how much sub-repo (i.e., how your files are classified) you need is up to you and the specific project you are developing.

- As an example, for a data analysis project you may have 5 sub-repo which are the following :
  - `raw-data` : contains the raw data used for the analysis, and should remain untouched.
  - `transformed-data` : this sub-repo is useful if you need to alter or transform the data, and then store it.
  - `analysis` : used to store the R scripts that are running the analysis and produce results.
  - `outputs` : may contain analysis results, like figures or tables.
  - `R`: contains only your own custom R functions, that you may have developed, and are called by the analysis scripts.

```
  .
  ├── my_project.Rproj
  ├── [raw-data]
  ├── [transformed-data]
  ├── [analysis]
  ├── [R]
  ├── [outputs]
  ├── README
  ├── DESCRIPTION
  ├── NAMESPACE
```

*The raw-data sub-repo contains the raw data used for the analysis, and should remain untouched. The transformed-data sub-repo is useful if you need to alter or transform the data, and then store it. In the analysis sub-repo, you may store the R scripts that are running the analysis and produce results. The outputs sub-repo may contain analysis results, like figures. The R sub-repo contains only your own custom R functions, that you may have developed, and are called by the analysis scripts.*

- Obviously, this structure should be adapted to each project complexity and needs. Nevertheless, remember that you are trying to facilitate the reuse of your code, so be careful to keep your organization simple and readable.

## Some other general good organisation practice

- Write each of your custom R functions in one single `.R` file

## Here is a list of useful R packages when developing R projects and/or packages

- [`devtools`](https://devtools.r-lib.org/) : a package that provides functions to ease the development of R packages, by executing common tasks like documentation, testing, etc. e.g.:
  - `devtools::document()` : generates the NAMESPACE file and documentation files for your functions
  - `devtools::load_all()` : loads your code and functions in the R environment, so that you can test them immediately
  - `devtools::test()` : runs the tests you have written for your functions
- [`usethis`](https://usethis.r-lib.org) : workflow automation package for R projects for setting up and develop projects, e.g.:
  - `usethis::use_git()` : initializes a git repository in your project
  - `usethis::use_testthat()` : initializes the `testthat` package in your project
  - `usethis::use_package("package")` : adds a package to the DESCRIPTION file as a dependency of your package
  - `usethis::use_r()` : creates a new `R` script in the R/ sub-repository
  - `usethis::use_test("myTest")` : creates a new test script `tests/testthat/test-myTest.R`
- [`here`](https://here.r-lib.org/) : a package that provides functions to easily refer to files in your project, e.g.:
  - `here::here()` : returns the path to the project root
  - `here::here("R", "my_function.R")` : returns the path to the `my_function.R` file in the `R` sub-repository
- [`testthat`](https://testthat.r-lib.org/) : a package that provides functions to write and run tests for your functions. Check the official documentation and [the dedicated section](testing.qmd#write-test) to see how to write tests. Once you have initiated your tests with `usethis::use_testthat()`, you can write tests in the `tests/testthat/` sub-repository:
  - `usethis::use_test("my_function")` : creates a new test script `tests/testthat/test-my_function.R`
  - `devtools::test()` : to run the tests.


# Python users

When coding in Python, you will have to make several choices regarding the tools you will use for your setup such as your [IDE](#ide) or [package manager](#package-manager).

## IDE

We recommand using `VSCode` when starting a Python project. It is the most widely used integrated development environment (IDE) by Python users and developers. It comes with a lot of extensions that can be installed, such as:
- `Python` / `ms-python.python` : the official extension for Python development. Base extension for other extensions. Allows the choose your Python interpreter, use the debugger, etc...
- `Pylance` / `ms-python.vscode-pylance` : a fast and feature-rich language server for Python (code completion, parameters suggestion, code navigation, etc...)
- `MyPy` / `ms-python.mypy-type-checker` : a type checker for Python. It checks your code for type errors and suggests fixes.
- `Pylint` / `ms-python.pylint` : a linter for Python. It checks your code for style errors and suggests fixes.
- `Ruff` / `charliermarsh.ruff` : an extremely fast Python linter and code formatter. Can be used to replace Flake8 (plus dozens of plugins), Black, isort, pyupgrade, and more
- `Jupyter` / `ms-toolsai.jupyter` : the official extension for Jupyter notebooks. Basic notebook support for language kernels that are supported in Jupyter Notebooks, and allows any Python environment to be used as a Jupyter kernel.
- `Copilot` / `github.copilot` : AI peer programming tool. Free but account needed.
- `Gitlens` / `eamodio.gitlens` : Git supercharged. It helps you with push, pull, multiple branches, commit history, and more.

## Package manager

You have multiple options in python for [building your package](https://packaging.python.org/en/latest/tutorials/packaging-projects/), [isolate your environment](https://www.w3schools.com/python/python_virtualenv.asp), and [manage your dependencies](https://packaging.python.org/en/latest/tutorials/managing-dependencies/). Some are "all-in-one" solutions, while others are more modular. Here are some of the most popular ones:
- [`pip`](https://packaging.python.org/en/latest/guides/tool-recommendations/#installing-packages) : the default package manager for Python. It is used to install and manage packages from the Python Package Index (PyPI). It is a good choice if you are working on a small project or if you are using a virtual environment.
- [`uv`](https://docs.astral.sh/uv/) : a new package manager that does everything `pip` does, but faster and with a better user experience. Probably your new by default choice. Also supports pre-defined [tasks](https://docs.astral.sh/uv/#scripts), [projects](https://docs.astral.sh/uv/#projects)
- [`poetry`](https://python-poetry.org/) : a dependency manager for Python. It is used to manage dependencies, build packages, and publish packages to PyPI. One of the most recent and popular "all-in-one" solution. Good documentation and easy to use.
- [`conda / mamba`](https://docs.conda.io/projects/conda/en/latest/user-guide/install/index.html#term-Miniforge) : package managers that are popular in the data science community. They allow you to create isolated environments and manage dependencies easily. Can also be used to install non-Python dependencies (compilers, R-packages, Julia-packages, ...). Prefer the `miniforge` version, cf. [dedicated section](./amap.qmd#using-conda-at-amap).
- [`pixi`](https://pixi.sh/) : a new package manager that is gaining popularity. Fast and easy to use, on top of the conda ecosystem. Very fast, and in many ways similar to `uv`, but with the advantage of being able to use all the conda packages.
- other options like `pipenv`, `virtualenv`, `venv`, `pyenv`, [hatch](https://hatch.pypa.io/latest), [`flit`](https://flit.pypa.io/en/stable/) also exist for environment management, but are less popular in the scientific academic community.


## Start version control with git

[How to use git](git.qmd)

## The files you need from the very beginning

Whether you are writing a full package or just a collection of scripts, it is important to start your project with a good organization. This will help you to keep your code clean and readable, easy to be shared and maintained, and adaptable to future changes.

Your basic structure should look like this:

```bash
pkg_name
├── CHANGELOG.md               ┐
├── README.md                  │
├── LICENSE                    │Package metadata and build configuration
├── pyproject.toml             ┘
├── doc                        ┐
│   └── index.md               │
│   └── ...                    │  Package documentation
│   └── examples               │
│   └──── notebook1.ipynb      │
│   └──── ...                  ┘
├── src                        ┐
│   └── pkg_name               │
│       ├── __init__.py        │ Package source code
│       ├── moduleA.py         │
│       └── moduleB.py         ┘
└── test                       ┐
   └── ...                     ┘ Package tests
```

- `CHANGELOG.md` : a file that contains the history of changes made to the package. It is useful to keep track of the changes made to the package and to communicate them to the users.
- `README.md` : a file that contains the short description of the package, how to install it, how to use it, and how to contribute to it. It is useful to communicate with the users and to provide them with the necessary information to use the package. It should also contain badges to indicate the package status (build, tests, coverage, etc.).
- `LICENSE` : a file that contains the license under which the package is distributed. Maybe the first file to add to your project. You can choose a license from <https://choosealicense.com>
- `pyproject.toml` : a file that contains the package metadata (name, version, author, description, etc.) and the build configuration (dependencies, build system, etc.). It is the main file for building and installing the package. To help you starting with this file, your [package / project manager](#package-manager) will help you to generate it. For example, with `poetry` / `pixi` / `flit` / `uv` / `hatch`, you can run `poetry / pixi / flit / uv / hatch init` to create the file and fill it with the necessary information. Otherwise, lots of information can be found in the _e.g._ [here](https://learn.scientific-python.org/development/guides/packaging-simple/)
- `doc/` : a directory that contains the package documentation, cf. [dedicated section](documentation.qmd/#python-users).
- `src/` : a directory that contains your scripts / code / modules. It is a good practice to put your code in a `src/` directory so that Python automatically recognizes it as a package (meaning you can then do an `from pkg_name.moduleA import functionA`), pending you add an `__init__.py` file in it. This file can be empty, but it is necessary to indicate that the directory is a package.
- `test/` : a directory that contains the package tests, cf. [dedicated section](testing.qmd#python-users).

## Use your package

To use your package and all the nice scripts and functions you have written, you need to install it. You can do this by running the following command in the root of your project:

```bash
pip install -e .
```

`pip` will install the package. It will look for the `pyproject.toml` file in the current directory (`.`) and install the package in editable mode (`-e`), meaning that any changes you make to the source code will be reflected in the installed package without needing to reinstall it. Make sure to properly define your package dependencies in the `pyproject.toml` file, so that they are installed automatically when you install your package.